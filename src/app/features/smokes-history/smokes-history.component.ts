import { AfterViewInit, ChangeDetectionStrategy, Component, ElementRef, ViewChild, inject } from '@angular/core';import { EntityAction, EntityActions } from '@datorama/akita';import { UntilDestroy, untilDestroyed } from '@ngneat/until-destroy';import { default as flatpickr } from 'flatpickr';import { DayElement, Instance } from 'flatpickr/dist/types/instance';import { Hook } from 'flatpickr/dist/types/options';import { tap } from 'rxjs';import { SmokesQuery } from 'src/app/core/smokes/smokes.query';import { ISmoke } from 'src/app/core/smokes/smokes.store';import { PanelService } from './panel.service';@UntilDestroy()@Component({	selector: 'app-smokes-history',	templateUrl: './smokes-history.component.html',	styleUrls: ['./smokes-history.component.scss'],	changeDetection: ChangeDetectionStrategy.OnPush,})export class SmokesHistoryComponent implements AfterViewInit {	private query: SmokesQuery = inject(SmokesQuery);	private panel: PanelService = inject(PanelService);	@ViewChild('container', { read: ElementRef }) private container!: ElementRef;	instance!: Instance;	daysIndex: Record<number, number> = {};	ngAfterViewInit(): void {		this.instance = flatpickr(this.container.nativeElement, {			inline: true,			maxDate: new Date(),			onDayCreate: (a, b, c, dayElement) => this.addCountBadge(dayElement),			onReady: [this.indexByDateHook()],			onMonthChange: [this.indexByDateHook()],			onChange: [				(dates, b, c, d) => {					this.panel.openPanel(dates[0], this.container, () => this.instance.clear(true, false));				},			],		});		(window as any).fp = this.instance;		this.query			.selectEntityAction([EntityActions.Add, EntityActions.Remove])			.pipe(				tap((action: EntityAction<string>) => {					const changedDates =						action.type === EntityActions.Add							? action.ids.map(id => new Date(this.query.getEntity(id)!.timestamp).setHours(0, 0, 0, 0))							: this.instance.selectedDates;					changedDates.forEach(date => this.addCountBadge(this.getDayElement(new Date(date))));				}),				untilDestroyed(this)			)			.subscribe();	}	getDayElement(date: Date): DayElement | null {		const nodes = this.instance.days.childNodes;		const index = this.daysIndex[date.valueOf()];		if (index < 0) return null;		return nodes[index] as DayElement;	}	indexByDateHook(): Hook {		return (a, b, instance) => {			this.daysIndex = this.indexByDate(instance.days.childNodes);		};	}	indexByDate(arr: ArrayLike<ChildNode>): Record<number, number> {		const result: Record<number, number> = {};		for (let index = 0; index < arr.length; index++) {			result[(arr[index] as DayElement).dateObj.valueOf()] = index;		}		return result;	}	addCountBadge(dayElement: DayElement | null): void {		if (!dayElement) return;		if (this.isDateInFuture(dayElement.dateObj)) return;		const count = this.getCountAtDay(dayElement.dateObj) ?? 0;		const date = dayElement.dateObj.getDate();		dayElement.innerHTML = `${date}<span class="day-count">${count}</span>`;	}	getBadgeClass(count: number): string {		switch (true) {			case count <= 9:				return 'success';			case count <= 11:				return 'regular';			default:				return 'warn';		}	}	getCountAtDay(day: Date): number {		return this.query.getCount((smoke: ISmoke) => new Date(smoke.timestamp).setHours(0, 0, 0, 0) === day.valueOf());	}	isDateInFuture(date: Date): boolean {		const today = new Date(new Date().setHours(0, 0, 0, 0));		return date > today;	}}